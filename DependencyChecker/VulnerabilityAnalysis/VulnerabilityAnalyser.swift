//
//  VulnerabilityAnalyser.swift
//  DependencyChecker
//
//  Created by Kristiina Rahkema on 02.01.2022.
//

import Foundation
import os.log

class VulnerabilityAnalyser {
    var vulnerabilities: VulnerabilityDictionary
    var url: URL
    var folder: URL
    var changed = false
    
    init() {
        let home = FileManager.default.homeDirectoryForCurrentUser
        self.folder = home.appendingPathComponent("DependencyInfo", isDirectory: true)
        
        self.url = self.folder.appendingPathComponent("vulnerabilities.json")
        
        if let data = try? Data(contentsOf: url) {
            let decoder = JSONDecoder()
            if let decoded = try? decoder.decode(VulnerabilityDictionary.self, from: data) {
                vulnerabilities = decoded
            } else {
                vulnerabilities = VulnerabilityDictionary(lastUpdated: Date())
            }
        } else {
            vulnerabilities = VulnerabilityDictionary(lastUpdated: Date())
        }
    }
    
    deinit {
        if changed {
            save()
        }
    }
    
    func save() {
        self.checkFolder()
        
        let encoder = JSONEncoder()
        if let encoded = try? encoder.encode(self.vulnerabilities) {
            do {
                try encoded.write(to: url)
            } catch {
                os_log("Could not save vulnerabilities")
            }
        }
    }
    
    func checkFolder() {
        if !FileManager.default.fileExists(atPath: self.folder.absoluteString) {
            do {
                try FileManager.default.createDirectory(at: self.folder, withIntermediateDirectories: true, attributes: nil)
            } catch {
                os_log("Could not create folder: \(self.folder)")
            }
        }
    }
    
    func queryVulnerabilitiesFor(cpe: String) -> [CVEData] {
        if let cveList = self.vulnerabilities.dictionary[cpe] {
            return cveList
        } else {
            var cveList: [CVEData] = []
            
            let group = DispatchGroup()
            group.enter()
            
            if let url = URL(string: "https://services.nvd.nist.gov/rest/json/cves/1.0?cpeMatchString=\(cpe)&resultsPerPage=2000") {
                sleep(6)
            URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) -> Void in
                defer { group.leave() }
                //os_log("response:\(response)")
                //TODO: handle response code, for example if it is 503
                // response shema: https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema
                if let data = data {
                    do {
                        if let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] {
                        //os_log("data: \(json)")
                            if let resultsPerPage = json["resultsPerPage"] as? Int, let totalResults = json["totalResults"] as? Int {
                                //os_log("[i] total results: \(totalResults)")
                                
                                if totalResults > 0 {
                                    //os_log("[i] results per page: \(resultsPerPage)")
                                    //os_log("json: \(json)")
                                    
                                    if let result = json["result"] as? [String: Any] {
                                        //os_log("result: \(result)")
                                        
                                        //os_log("cpes: \(result["CVE_Items"])")
                                        
                                        if let cves = result["CVE_Items"] as? [[String: Any]] {
                                            //os_log("[i] number of cves: \(cves.count)")
                                            
                                            //os_log("cves: \(cves)")
                                            
                                            for cve in cves {
                                                //os_log("cve: \(cve)")
                                                var cveData = CVEData(fromJson: cve)
                                                
                                                cveList.append(cveData)
                                                
                                            }
                                            /*
                                            for cve in cves {
                                                if let cpeuri = cpe["cpe23Uri"] as? String {
                                                    os_log("[i] cpe: \(cpeuri)")
                                                    
                                                    if cpeuri.contains(projectName) {
                                                        addLineToLogFile(line: "cpe: \(cpeuri)")
                                                    } else {
                                                        continue
                                                    }
                                                }
                                            }
         */
                                        } else {
                                            os_log("[i] cves object not found")
                                        }
                                    }
                                  //  break
                                }
                            }
                        } else {
                            os_log("[!] No json.")
                        }
                    } catch {
                        os_log("[!] Failed parsing json.")
                    }
                }
            }).resume()
            group.wait()
           // break
            }
            self.vulnerabilities.dictionary[cpe] = cveList
            self.changed = true
            
            return cveList
        }
    }
}

class VulnerabilityDictionary: Codable {
    var lastUpdated: Date
    var dictionary: [String: [CVEData]]
    
    init(lastUpdated: Date) {
        self.lastUpdated = lastUpdated
        self.dictionary = [:]
    }
}

class CVEData: Codable {
    var publishedDate: String?
    var lastModifiedDate: String?
    
    var configuration: Configuration?
    var impact: Impact?
    var cve: CVE? // required value
    
    init(fromJson: [String: Any]) {
        self.publishedDate = fromJson["publishedDate"] as? String
        self.lastModifiedDate = fromJson["lastModifiedDate"] as? String
        
        if let configuration = fromJson["configurations"] as? [String: Any] {
            if let nodes = configuration["nodes"] as? [[String: Any]] {
                self.configuration = Configuration(fromJson: nodes)
            }
        }
        
        if let impact = fromJson["impact"] as? [String: Any] {
            self.impact = Impact(fromJson: impact)
        }
        
        if let cve = fromJson["cve"] as? [String: Any] {
            self.cve = CVE(fromJson: cve)
        }
    }
}

class CVE: Codable {
    var description: String? // required
    var problemType: String? // required
    var references: [Reference] = [] // required
    
    init(fromJson: [String: Any]) {
        if let descriptionObject = fromJson["description"] as? [String:Any] {
            self.description = ""
            if let descriptionData = descriptionObject["description_data"] as? [[String: Any]] {
                for description in descriptionData {
                    if let language = description["lang"] as? String, let value = description["value"] as? String {
                        if self.description?.count == 0 {
                            self.description = "\(language): \(value)"
                        } else {
                            self.description = "\(self.description), \(language): \(value)"
                        }
                    }
                }
            }
        }
        
        if let problemTypeObject = fromJson["problemtype"] as? [String: Any] {
            self.problemType = ""
            if let problemTypeData = problemTypeObject["problemtype_data"] as? [[String: Any]] {
                for problemType in problemTypeData {
                    if let problemTypeDescriptions = problemType["description"] as? [[String: Any]] {
                        for problemTypeDescription in problemTypeDescriptions {
                            if let language = problemTypeDescription["lang"] as? String, let value = problemTypeDescription["value"] as? String {
                                if self.problemType?.count == 0 {
                                    self.problemType = "\(language): \(value)"
                                } else {
                                    self.problemType = "\(self.problemType), \(language): \(value)"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if let referencesObject = fromJson["references"] as? [String: Any] {
            self.references = []
            if let referencesData = referencesObject["reference_data"] as? [[String: Any]] {
                for reference in referencesData {
                    self.references.append(Reference(fromJson: reference))
                }
            }
        }
        /*
         also exists:
         #affects
         #CVE_data_meta required
         #data_type required
         #data_version required
         #data_fromat required
         */
    }
    
}

class Reference: Codable {
    var name: String?
    var refSource: String?
    var tags: [String]
    var url: String? // required
    
    init(fromJson: [String: Any]) {
        self.name = fromJson["name"] as? String
        self.refSource = fromJson["refsource"] as? String
        self.url = fromJson["url"] as? String
        
        if let tags = fromJson["tags"] as? [String] {
            self.tags = tags
        } else {
            self.tags = []
        }
    }
}

class Configuration: Codable {
    // also has
    // CVE_data_version, required
    var nodes: [Node] = []
    
    init(fromJson: [[String: Any]]) {
        self.nodes = []
        for node in fromJson {
            nodes.append(Node(fromJson: node))
        }
    }
    
    var affectedVersions: [CPEMatch] {
        var list: [CPEMatch] = []
        for node in nodes {
            list.append(contentsOf: node.affectedVersions)
        }
        return list
    }
}

/*
 nodes =     (
                 {
             children =             (
             );
             "cpe_match" =             (
                                 {
                     cpe23Uri = "cpe:2.3:a:atlassian:connect_spring_boot:*:*:*:*:*:*:*:*";
                     "cpe_name" =                     (
                     );
                     versionEndExcluding = "2.1.3";
                     versionStartIncluding = "1.1.0";
                     vulnerable = 1;
                 }
             );
             operator = OR;
         }
     );
 */

class Node: Codable {
    var children: [Node] = []
    var cpeMatch: [CPEMatch] = []
    var operatorString: String //TODO: make operator as enum?
    // also
    // negate
    //
    
    var affectedVersions: [CPEMatch] {
        var list: [CPEMatch] = []
        for node in children {
            list.append(contentsOf: node.affectedVersions)
        }
        
        for cpeMatch in self.cpeMatch {
            list.append(cpeMatch)
        }
        
        return list
    }
    
    init(fromJson: [String: Any]) {
        if let children = fromJson["children"] as? [[String:Any]] {
            for child in children {
                self.children.append(Node(fromJson: child))
            }
        }
        
        if let cpeMatch = fromJson["cpe_match"] as? [[String:Any]] {
            for match in cpeMatch {
                self.cpeMatch.append(CPEMatch(fromJson: match))
            }
        }
        
        if let operatorString = fromJson["operator"] as? String {
            self.operatorString = operatorString
        } else {
            self.operatorString = "--" // should not happen
        }
    }
}

class CPEMatch: Codable {
    /*
     "cpe_match" =             (
                                     {
                         cpe23Uri = "cpe:2.3:a:atlassian:connect_spring_boot:*:*:*:*:*:*:*:*";
                         "cpe_name" =                     (
                         );
                         versionEndExcluding = "2.1.3";
                         versionStartIncluding = "1.1.0";
                         vulnerable = 1;
                     }
                 );
     */
    var cpeString: String // required
    var versionEndExcluding: String?
    var versionEndIncluding: String?
    var versionStartIncluding: String?
    var versionStartExcluding: String?
    var vulnerable: Bool // required
    // other
    // cpe22Uri
    // cpe_name (array of cpe names)
    
    init(fromJson: [String: Any]) {
        if let cpe23Uri = fromJson["cpe23Uri"] as? String {
            self.cpeString = cpe23Uri
        } else {
            self.cpeString = "Not found" // should never happen
        }
        
        if let vulnerable = fromJson["vulnerable"] as? Bool {
            self.vulnerable = vulnerable
        } else {
            self.vulnerable = false // should never happen
        }
        
        if let versionEndExcluding = fromJson["versionEndExcluding"] as? String {
            self.versionEndExcluding = versionEndExcluding
        }
        
        if let versionEndIncluding = fromJson["versionEndIncluding"] as? String {
            self.versionEndIncluding = versionEndIncluding
        }
        
        if let versionStartIncluding = fromJson["versionStartIncluding"] as? String {
            self.versionStartIncluding = versionStartIncluding
        }
        
        if let versionStartExcluding = fromJson["versionStartExcluding"] as? String {
            self.versionStartExcluding = versionStartExcluding
        }
    }
}

class Impact: Codable {
    var baseMetricV3: BaseMetric?
    var baseMetricV2: BaseMetric?
    
    init(fromJson: [String: Any]) {
        if let baseMetricV2 = fromJson["baseMetricV2"] as? [String: Any] {
            let parsedV2 = BaseMetric(fromV2Json: baseMetricV2)
            self.baseMetricV2 = parsedV2
        }
        
        if let baseMetricV3 = fromJson["baseMetricV3"] as? [String: Any] {
            let parsedV3 = BaseMetric(fromV3Json: baseMetricV3)
            self.baseMetricV3 = parsedV3
        }
    }
}

class BaseMetric: Codable {
    var attackComplexity: String?        //v3,   v2 (accessComplexity)
    var attackVector: String?            //v3,   v2
    var authentication: String?          //      v2
    var availabilityImpact: String?      //v3,   v2
    var baseScore: String?               //v3,   v2
    var baseSeverity: String?            //v3,   v2 (severity)
    var confidentialityImpact: String?   //v3,   v2
    var integrityImpact: String?         //v3,   v2
    var privilegesRequired: String?      //v3    (== authentication??)
    var scope: String?                   //v3
    var userInteractionRequired: String? //v3 (userInteraction) ,   v2
    var vectorString: String?            //v3,   v2
    var exploitabilityScore: String?     //v3,   v2
    var impactScore: String?             //v3,   v2
    var version: MetricVersion          //
    var obtainAllPrivilege: Bool?        //      v2
    var obtainOtherPrivilege: Bool?      //      v2
    var obtainUserPrivilege: Bool?       //      v2
    
    enum MetricVersion: Int, Codable {
        case V2 = 2
        case V3 = 3
    }
    
    init(fromV3Json: [String: Any]) {
        /*
         baseMetricV3 =     {
                cvssV3 =         {
                    attackComplexity = LOW;
                    attackVector = NETWORK;
                    availabilityImpact = NONE;
                    baseScore = "7.1";
                    baseSeverity = HIGH;
                    confidentialityImpact = LOW;
                    integrityImpact = HIGH;
                    privilegesRequired = NONE;
                    scope = UNCHANGED;
                    userInteraction = REQUIRED;
                    vectorString = "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:N";
                    version = "3.1";
                };
                exploitabilityScore = "2.8";
                impactScore = "4.2";
            };
         */
        
        if let cvssV3 = fromV3Json["cvssV3"] as? [String: Any] {
            if let attackComplexity = cvssV3["attackComplexity"] as? String {
                self.attackComplexity = attackComplexity
            }
            
            if let attackVector = cvssV3["attackVector"] as? String {
                self.attackVector = attackVector
            }
            
            if let availabilityImpact = cvssV3["availabilityImpact"] as? String {
                self.availabilityImpact = availabilityImpact
            }
            
            if let baseScore = cvssV3["baseScore"] as? String {
                self.baseScore = baseScore
            }
            
            if let baseSeverity = cvssV3["baseSeverity"] as? String {
                self.baseSeverity = baseSeverity
            }
            
            if let confidentialityImpact = cvssV3["confidentialityImpact"] as? String {
                self.confidentialityImpact = confidentialityImpact
            }
            
            if let integrityImpact = cvssV3["integrityImpact"] as? String {
                self.integrityImpact = integrityImpact
            }
            
            if let privilegesRequired = cvssV3["privilegesRequired"] as? String {
                self.privilegesRequired = privilegesRequired
            }
            
            if let scope = cvssV3["scope"] as? String {
                self.scope = scope
            }
            
            if let userInteraction = cvssV3["userInteraction"] as? String {
                self.userInteractionRequired = userInteraction
            }
            
            if let vectorString = cvssV3["vectorString"] as? String {
                self.vectorString = vectorString
            }
        }
        
        if let exploitabilityScore = fromV3Json["exploitabilityScore"] as? String {
            self.exploitabilityScore = exploitabilityScore
        }
        
        if let impactScore = fromV3Json["impactScore"] as? String {
            self.impactScore = impactScore
        }
        
        self.version = .V3
    }
    
    init(fromV2Json: [String: Any]) {
        /*
         baseMetricV2 =     {
             acInsufInfo = 0;
             cvssV2 =         {
                 accessComplexity = LOW;
                 accessVector = NETWORK;
                 authentication = NONE;
                 availabilityImpact = COMPLETE;
                 baseScore = 10;
                 confidentialityImpact = COMPLETE;
                 integrityImpact = COMPLETE;
                 vectorString = "AV:N/AC:L/Au:N/C:C/I:C/A:C";
                 version = "2.0";
             };
             exploitabilityScore = 10;
             impactScore = 10;
             obtainAllPrivilege = 0;
             obtainOtherPrivilege = 0;
             obtainUserPrivilege = 0;
             severity = HIGH;
             userInteractionRequired = 0;
         };
         */
        
        if let cvssV2 = fromV2Json["cvssV2"] as? [String: Any] {
            if let accessComplexity = cvssV2["accessComplexity"] as? String {
                self.attackComplexity = accessComplexity
            }
            
            if let accessVector = cvssV2["accessVector"] as? String {
                self.attackVector = accessVector
            }
            
            if let authentication = cvssV2["authentication"] as? String {
                self.authentication = authentication
            }
            
            if let availabilityImpact = cvssV2["availabilityImpact"] as? String {
                self.availabilityImpact = availabilityImpact
            }
            
            if let baseScore = cvssV2["baseScore"] as? String {
                self.baseScore = baseScore
            }
            
            if let confidentialityImpact = cvssV2["confidentialityImpact"] as? String {
                self.confidentialityImpact = confidentialityImpact
            }
            
            if let integrityImpact = cvssV2["integrityImpact"] as? String {
                self.integrityImpact = integrityImpact
            }
            
            if let vectorString = cvssV2["vectorString"] as? String {
                self.vectorString = vectorString
            }
        }
        
        if let exploitabilityScore = fromV2Json["exploitabilityScore"] as? String {
            self.exploitabilityScore = exploitabilityScore
        }
        
        if let impactScore = fromV2Json["impactScore"] as? String {
            self.impactScore = impactScore
        }
        
        if let obtainAllPrivilege = fromV2Json["obtainAllPrivilege"] as? Bool {
            self.obtainAllPrivilege = obtainAllPrivilege
        }
        
        if let obtainOtherPrivilege = fromV2Json["obtainOtherPrivilege"] as? Bool {
            self.obtainOtherPrivilege = obtainOtherPrivilege
        }
        
        if let obtainUserPrivilege = fromV2Json["obtainUserPrivilege"] as? Bool {
            self.obtainUserPrivilege = obtainUserPrivilege
        }
        
        if let severity = fromV2Json["severity"] as? String {
            self.baseSeverity = severity
        }
        
        if let userInteractionRequired = fromV2Json["userInteractionRequired"] as? Bool {
            self.userInteractionRequired = "\(userInteractionRequired)"
        }
        
        self.version = .V2
    }
}
